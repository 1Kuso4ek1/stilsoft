/*
    Вопрос 1:
        Напишите прототипы функций для следующих случаев. При необходимости используйте const.

        a) Функция с именем max(), которая принимает два значения double и возвращает большее из двух.
        double max(double a, double b);

        b) Функция под названием swap(), которая меняет местами два числа int.
        void swap(int& a, int& b);

        c) Функция с именем getLargestElement(), которая принимает динамически выделенный массив чисел int и возвращает наибольшее число таким образом, что вызывающий может изменить значение возвращаемого элемента (не забудьте параметр длины).
        int& getLargestElement(int* a, int length);

    Вопрос 2:
        Что не так с этими фрагментами кода?

        a) Возвращается ссылка на элемент локального массива

        int& doSomething()
        {
            int array[]{ 1, 2, 3, 4, 5 };
            return array[3];
        }

        b) Бесконечная рекурсия

        int sumTo(int value)
        {
            return value + sumTo(value - 1);
        }

        c) Перегруженные функции не могут отличаться только типом возвращаемого значения

        float divide(float x, float y)
        {
            return x / y;
        }
        
        double divide(float x, float y)
        {
            return x / y;
        }

        d) Слишком большой размер массива для размещения в стеке

        #include <iostream>
        
        int main()
        {
            int array[100000000]{};
        
            for (auto x: array)
                std::cout << x << ' ';
        
            std::cout << '\n';
        
            return 0;
        }

        e) argv - это массив char, а не int. Также argv[1] может не существовать.

        #include <iostream>
        
        int main(int argc, char *argv[])
        {
            int age{ argv[1] };
            std::cout << "The user's age is " << age << '\n';
        
            return 0;
        }

    Вопрос 3:
        Лучший алгоритм определения наличия значения в отсортированном массиве называется двоичным (бинарным) поиском.

        Бинарный поиск работает следующим образом:

            Найти центральный элемент массива (если в массиве четное количество элементов, округлить в меньшую сторону).
            Если центральный элемент больше целевого элемента, отбросить верхнюю половину массива (или выполнить рекурсию для нижней половины)
            Если центральный элемент меньше целевого элемента, отбросить нижнюю половину массива (или выполнить рекурсию для верхней половины).
            Если центральный элемент равен целевому элементу, вернуть индекс центрального элемента.
            Если отбрасывается весь массив, не найдя целевой элемент, вернуть контрольное значение, которое представляет «не найден» (в этом случае мы будем использовать -1, поскольку это недопустимый индекс массива).

        Поскольку с каждой итерацией мы можем отбрасывать половину массива, этот алгоритм очень быстр. Даже с массивом из миллиона элементов требуется не более 20 итераций, чтобы определить, присутствует ли значение в массиве или нет! Однако он работает только с отсортированными массивами.

        Изменение массива (например, отбрасывание половины элементов в массиве) стоит дорого, поэтому обычно мы не модифицируем массив. Вместо этого мы используем два целых числа (min и max) для хранения индексов минимального и максимального элементов массива, который мы хотим исследовать.

        Давайте посмотрим на пример того, как работает этот алгоритм, на массиве {3, 6, 7, 9, 12, 15, 18, 21, 24} и целевом значении 7. Сначала min = 0, max = 8, потому что мы ищем во всем массив (длина массива 9, поэтому индекс последнего элемента равен 8).

            Шаг 1) Вычисляем среднюю точку min (0) и max (8), которая равна 4. Элемент № 4 имеет значение 12, которое больше нашего целевого значения. Поскольку массив отсортирован, мы знаем, что все элементы с индексом, равным или превышающим среднюю точку (4), должны быть слишком большими. Поэтому мы оставляем min неизменным и устанавливаем max равным 3.
            Шаг 2) Мы вычисляем среднюю точку min (0) и max (3), которая равна 1. Элемент № 1 имеет значение 6, которое меньше нашего целевого значения. Поскольку массив отсортирован, мы знаем, что все элементы с индексом, равным или меньшим средней точки (1), должны быть слишком маленькими. Поэтому мы устанавливаем min на 2, а max не меняем.
            Шаг 3) Мы вычисляем среднюю точку min (2) и max (3), которая равна 2. Элемент № 2 имеет значение 7, которое является нашим целевым значением. Итак, возвращаем 2.

        a) Напишите итеративную версию функции binarySearch.
        b) Напишите рекурсивную версию функции binarySearch.
*/

#include <iostream>
#include <iterator>

// array - это массив для поиска.
// target - это значение, которое мы пытаемся определить, есть оно или нет.
// min - это индекс нижней границы массива, в котором мы ищем.
// max - это индекс верхней границы массива, в котором мы ищем.
// binarySearch() должна возвращать индекс целевого элемента, если target найден, иначе -1
int binarySearch(const int *array, int target, int min, int max)
{
    do
    {
        int middle = (max + min) / 2;

        if(array[middle] == target)
            return middle;
        else if(array[middle] > target)
            max = middle - 1;
        else if(array[middle] < target)
            min = middle + 1;
    } while(min <= max);

    return -1;
}

int binarySearchRecursive(const int *array, int target, int min, int max)
{
    if(min <= max)
    {
        int middle = (max + min) / 2;

        if(array[middle] == target)
            return middle;
        else if(array[middle] > target)
            return binarySearchRecursive(array, target, min, middle - 1);
        else if(array[middle] < target)
            return binarySearchRecursive(array, target, middle + 1, max);
    }

    return -1;
}

int main()
{
    constexpr int array[]{ 3, 6, 8, 12, 14, 17, 20, 21, 26, 32, 36, 37, 42, 44, 48 };

    // Мы собираемся протестировать набор значений, чтобы увидеть,
    // дают ли они ожидаемые результаты
    constexpr int numTestValues{ 9 };
    // Вот тестовые значения
    constexpr int testValues[numTestValues]{ 0, 3, 12, 13, 22, 26, 43, 44, 49 };
    // А вот ожидаемые результаты для каждого значения
    int expectedValues[numTestValues]{ -1, 0, 3, -1, -1, 8, -1, 13, -1 };

    // Перебираем все тестовые значения
    for (int count{ 0 }; count < numTestValues; ++count)
    {
        // Смотрим, есть ли наше тестовое значение в массиве
        int index{ binarySearch(array, testValues[count], 0, static_cast<int>(std::size(array)) - 1) };
        // Если результат соответствует ожидаемому, тогда отлично!
        if (index == expectedValues[count])
             std::cout << "test value " << testValues[count] << " passed!\n";
        else // иначе наша функция binarySearch() не работает
             std::cout << "test value " << testValues[count] << " failed. Index = " << index << ". There's something wrong with your code!\n";
    }

    return 0;
}
